# -*- coding: utf-8 -*-
"""EE 225 Final Project Phase 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oLYiax80Ip_lUHs0tzGeifwg9U8y9bgP

# EE 225: Introduction to Quantum Computing 
# Final Project: Phase 2 (Deustch Algorithm)
# MSEE San Jose State University 
# Hector Jose Morrell Jr

## Summary

Implement Deutsch-Jozsa Algorithm in Co-lab. We are generating our own Quantum Oracle that is fully functionuing using Deustch Algorithm. We are implementing this code to operate and do an interative function to calculate the algorithm 100 times. This is to find the statistical average to ensure our Oracle is functing properly.

The Deutsch -Jozsa Algorithm is a deterministic quantum algorithm that was invented in 192 by David Deutsch and Richard Jozsa. This algorithm is not an algorithm that is used practically in funtions but used as a algorithm to show the speed and power of quantum.

### Expectations

Deutsch Algorithm is a deterministic quantum Algorithm that takes the principle of a "Black Box" quantum computer that is known as an Oracle. This oracle implements some function, by taking in n-digit Binary values from qubits and produces either a 0 or a 1. The output (0 or 1) is ued to determine whether the function is constant or Non-constant. Bleow is the quantum circuit for the algorithm and the test benches we are using for this project.

![download.png](data:image/png;base64,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)
 

    f(0) = 0 and f(1) = 0 -- Return 0 --> Constant 

    f(0) = 0 and f(1) = 1 -- Return 1 --> Non-constant

    f(0) = 1 and f(1) = 0 -- Return 1 --> Non-constant

    f(0) = 1 and f(1) = 1 -- Return 0 --> Constant

The code below simulated the 4 quantum oracles we have derived to determine each function and whether it is constant or non-constant.

#### Code

Oracle #1 --> f(0) = 0 and f(1) = 0
"""

# Hector Jose Morrell Jr
# MSEE San Jose State University
# EE 225 Final Project Phase 2
# This Code is to simulate Quantum Oracle (Deutsch Algorithm)

import numpy as np
from math import sqrt

################################## Variables Section ##################################

z = 1
y = 1

# Initializing qubit bit 1 to |0>
q1 = np.array([1, 0])

# Initializing qubit bit 2 to |0>
q2 = np.array([1, 0])

# Not Gate Matrix
NOT_1bit = [[0, 1],
            [1, 0]]

# Identity Matrix
I = [[1, 0],
     [0, 1]]

# Hadamard Gate
H = [[1 / sqrt(2), 1 / sqrt(2)],
     [1 / sqrt(2), -1 / sqrt(2)]]

# Quantum Oracle
Uf = np.kron(I, I)

p1 = q1.dot(NOT_1bit)

################################## Initial Conditions Section ##################################

# Setting initial conditions for both bits
p0 = np.kron(q1, q2)
print('Intialized quibits')
print(p0)

# I tensor X
p1 = np.kron(NOT_1bit, I)
# print('\n'"I tensor X")
# print(psy1)

# To Hadamard Both bits
p2 = np.kron(H, H)
# print('\n''H tensor H')
# print(psy2)

# To Hadamard bit 1 and Identity bit 0
p4 = np.kron(I, H)
# print('\n''H tensor I')
# print(psy4)

################################## Algorithm Section ##################################

def Deustch_Algorithm(Uf, p0, p1, p2, p4, z):
    # Initial state times (I tensor X)
    psy1 = p1.dot(p0)

    # Applying the Hadamard to both bits
    psy2 = p2.dot(psy1)

    # Applying the Quantum Oracle
    psy3 = Uf.dot(psy2)

    # Applying Hadarmard Gate to first Bit (H tensor I)
    psy4 = p4.dot(psy3)

    if z == 1:
        print("\n" "Psy 1" "\n", psy1)
        print("\n" "Psy 2" "\n", psy2)
        print("\n" "Quantum Oracle Output" "\n", psy3)
        print("\n" "Psy 4" "\n", psy4)
    
    if psy4[0] != 0 and psy4[2] != 0:
      return 0

if y == 0:
    z = 1
    Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
if y == 1:
    z = 0
    Deustch_Algorithm(Uf, p0, p1, p2, p4, 1)
    for i in range(100):
        Final_Out = Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
        print("\n" "Final", i+1, Final_Out)

"""Oracle #2 --> f(0) = 1 and f(1) = 1 """

# Hector Jose Morrell Jr
# MSEE San Jose State University
# EE 225 Final Project Phase 2
# This Code is to simulate Quantum Oracle (Deutsch Algorithm)

import numpy as np
from math import sqrt

################################## Variables Section ##################################

z = 1
y = 1

# Initializing qubit bit 1 to |0>
q1 = np.array([1, 0])

# Initializing qubit bit 2 to |0>
q2 = np.array([1, 0])

# Not Gate Matrix
NOT_1bit = [[0, 1],
            [1, 0]]

# Identity Matrix
I = [[1, 0],
     [0, 1]]

# Hadamard Gate
H = [[1 / sqrt(2), 1 / sqrt(2)],
     [1 / sqrt(2), -1 / sqrt(2)]]

# Quantum Oracle
Uf = np.kron(NOT_1bit, I)

################################## Initial Conditions Section ##################################

# Setting initial conditions for both bits
p0 = np.kron(q1, q2)
print('Intialized quibits')
print(p0)

# I tensor X
p1 = np.kron(NOT_1bit, I)
# print('\n'"I tensor X")
# print(psy1)

# To Hadamard Both bits
p2 = np.kron(H, H)
# print('\n''H tensor H')
# print(psy2)

# To Hadamard bit 1 and Identity bit 0
p4 = np.kron(I, H)
# print('\n''H tensor I')
# print(psy4)

################################## Algorithm Section ##################################

def Deustch_Algorithm(Uf, p0, p1, p2, p4, z):
    # Initial state times (I tensor X)
    psy1 = p1.dot(p0)

    # Applying the Hadamard to both bits
    psy2 = p2.dot(psy1)

    # Applying the Quantum Oracle
    psy3 = Uf.dot(psy2)

    # Applying Hadarmard Gate to first Bit (H tensor I)
    psy4 = p4.dot(psy3)

    if z == 1:
        print("\n" "Psy 1" "\n", psy1)
        print("\n" "Psy 2" "\n", psy2)
        print("\n" "Quantum Oracle Output" "\n", psy3)
        print("\n" "Psy 4" "\n", psy4)

    if psy4[0] != 0 and psy4[2] != 0:
      return 0

if y == 0:
    z = 1
    Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
if y == 1:
    z = 0
    Deustch_Algorithm(Uf, p0, p1, p2, p4, 1)
    for i in range(100):
        Final_Out = Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
        print("\n" "Final", i+1, Final_Out)

"""Oracle #3 --> f(0) = 1 and f(1) = 0"""

# Hector Jose Morrell Jr
# MSEE San Jose State University
# EE 225 Final Project Phase 2
# This Code is to simulate Quantum Oracle (Deutsch Algorithm)

import numpy as np
from math import sqrt

################################## Variables Section ##################################

z = 1
y = 1

# Initializing qubit bit 1 to |0>
q1 = np.array([1, 0])

# Initializing qubit bit 2 to |0>
q2 = np.array([1, 0])

# Not Gate Matrix
NOT_1bit = [[0, 1],
            [1, 0]]

# Identity Matrix
I = [[1, 0],
     [0, 1]]

# Hadamard Gate
H = [[1 / sqrt(2), 1 / sqrt(2)],
     [1 / sqrt(2), -1 / sqrt(2)]]

# Quantum Oracle
Uf = np.array([[1, 0, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0],
               [0, 1, 0, 0]])

################################## Initial Conditions Section ##################################

# Setting initial conditions for both bits
p0 = np.kron(q1, q2)
print('Intialized quibits')
print(p0)

# I tensor X
p1 = np.kron(NOT_1bit, I)
# print('\n'"I tensor X")
# print(psy1)

# To Hadamard Both bits
p2 = np.kron(H, H)
# print('\n''H tensor H')
# print(psy2)

# To Hadamard bit 1 and Identity bit 0
p4 = np.kron(I, H)
# print('\n''H tensor I')
# print(psy4)

################################## Algorithm Section ##################################

def Deustch_Algorithm(Uf, p0, p1, p2, p4, z):
    # Initial state times (I tensor X)
    psy1 = p1.dot(p0)

    # Applying the Hadamard to both bits
    psy2 = p2.dot(psy1)

    # Applying the Quantum Oracle
    psy3 = Uf.dot(psy2)

    # Applying Hadarmard Gate to first Bit (H tensor I)
    psy4 = p4.dot(psy3)

    if z == 1:
        print("\n" "Psy 1" "\n", psy1)
        print("\n" "Psy 2" "\n", psy2)
        print("\n" "Quantum Oracle Output" "\n", psy3)
        print("\n" "Psy 4" "\n", psy4)

    if psy4 [0] == 0 and psy4[2] == 0:
      return 1

if y == 0:
    z = 1
    Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
if y == 1:
    z = 0
    Deustch_Algorithm(Uf, p0, p1, p2, p4, 1)
    for i in range(100):
        Final_Out = Deustch_Algorithm(Uf, p0, p1, p2, p4, z)
        print("\n" "Final", i+1, Final_Out)

"""Oracle #4 --> f(0) = 0 and f(1) = 1 """

# Hector Jose Morrell Jr
# MSEE San Jose State University
# EE 225 Final Project Phase 2
# This Code is to simulate Quantum Oracle (Deutsch Algorithm)

import numpy as np
from math import sqrt

################################## Variables Section ##################################

z = 1
y = 1

# Initializing qubit bit 1 to |0>
q1 = np.array([1, 0])

# Initializing qubit bit 2 to |0>
q2 = np.array([1, 0])

# Not Gate Matrix
NOT_1bit = [[0, 1],
            [1, 0]]

# Identity Matrix
I = [[1, 0],
     [0, 1]]

# Hadamard Gate
H = [[1 / sqrt(2), 1 / sqrt(2)],
     [1 / sqrt(2), -1 / sqrt(2)]]

# Quantum Oracle
Uf = np.array([[1, 0, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0],
               [0, 1, 0, 0]])

################################## Initial Conditions Section ##################################

# Setting initial conditions for both bits
p0 = np.kron(q1, q2)
print('Intialized quibits')
print(p0)

# I tensor X
p1 = np.kron(NOT_1bit, I)
# print('\n'"I tensor X")
# print(psy1)

# To Hadamard Both bits
p2 = np.kron(H, H)
# print('\n''H tensor H')
# print(psy2)

p3 = np.kron(I, NOT_1bit)

# To Hadamard bit 1 and Identity bit 0
p4 = np.kron(I, H)
# print('\n''H tensor I')
# print(psy4)

################################## Algorithm Section ##################################

def Deustch_Algorithm(Uf, p0, p1, p2, p3, p4, z):
    # Initial state times (I tensor X)
    psy1 = p1.dot(p0)

    # Applying the Hadamard to both bits
    psy2 = p2.dot(psy1)

    # Applying the Quantum Oracle
    psy3_1 = p3.dot(psy2)
    psy3_2 = Uf.dot(psy3_1)
    psy3 = p3.dot(psy3_2)

    # Applying Hadarmard Gate to first Bit (H tensor I)
    psy4 = p4.dot(psy3)

    if z == 1:
        print("\n" "Psy 1" "\n", psy1)
        print("\n" "Psy 2" "\n", psy2)
        print("\n" "Quantum Oracle Output" "\n", psy3)
        print("\n" "Psy 4" "\n", psy4)

    if psy4[0] == 0 and psy4[2] == 0:
      return 1

if y == 0:
    z = 1
    Deustch_Algorithm(Uf, p0, p1, p3, p2, p4, z)
if y == 1:
    z = 0
    Deustch_Algorithm(Uf, p0, p1, p2, p3, p4, 1)
    for i in range(100):
        Final_Out = Deustch_Algorithm(Uf, p0, p1, p2, p3, p4, z)
        print("\n" "Final", i+1, Final_Out)

"""##### Results

The code above is simulating as expected. Using IBMQ I could go section by section to ensure that the wave function was operating according. Each section has the appropriate wavefunction and outputing either a 0 or a 1 so that the user knows that the function is either constant or non-constant.

###### Conclusion

The circuit and oracles work as expected. What could be done now is with the experience given to me by phase 1(programing a quantum gate simulator) and phase 2(Quantum Oracle) I can expand the use of these programs for use in the theoretical field.
"""